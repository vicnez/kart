"use strict";
exports.id = 917;
exports.ids = [917];
exports.modules = {

/***/ 86917:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const Debug = __webpack_require__(15158);
const os_1 = __webpack_require__(12087);
const cloneDeep = __webpack_require__(83465);
const assign = __webpack_require__(31730);
const chalk_1 = __webpack_require__(32589);
const errors_1 = __webpack_require__(55191);
const snyk = __webpack_require__(9146);
const types_1 = __webpack_require__(55246);
const formatters_1 = __webpack_require__(81329);
const utils = __webpack_require__(77978);
const ecosystems_1 = __webpack_require__(5168);
const vuln_helpers_1 = __webpack_require__(14784);
const format_test_results_1 = __webpack_require__(59744);
const validate_credentials_1 = __webpack_require__(4593);
const validate_test_options_1 = __webpack_require__(83476);
const set_default_test_options_1 = __webpack_require__(13285);
const process_command_args_1 = __webpack_require__(52369);
const format_test_error_1 = __webpack_require__(68214);
const display_result_1 = __webpack_require__(89667);
const analytics = __webpack_require__(82744);
const protect_update_notification_1 = __webpack_require__(79304);
const spotlight_vuln_notification_1 = __webpack_require__(24083);
const iac_1 = __webpack_require__(55935);
const debug = Debug('snyk-test');
const SEPARATOR = '\n-------------------------------------------------------\n';
// TODO: avoid using `as any` whenever it's possible
async function test(...args) {
    const { options: originalOptions, paths } = process_command_args_1.processCommandArgs(...args);
    if (originalOptions.iac) {
        return await iac_1.default(false, ...args);
    }
    const options = set_default_test_options_1.setDefaultTestOptions(originalOptions);
    validate_test_options_1.validateTestOptions(options);
    validate_credentials_1.validateCredentials(options);
    const packageJsonPathsWithSnykDepForProtect = protect_update_notification_1.getPackageJsonPathsContainingSnykDependency(options.file, paths);
    analytics.add('upgradable-snyk-protect-paths', packageJsonPathsWithSnykDepForProtect.length);
    // Handles no image arg provided to the container command until
    // a validation interface is implemented in the docker plugin.
    if (options.docker && paths.length === 0) {
        throw new errors_1.MissingArgError();
    }
    const ecosystem = ecosystems_1.getEcosystemForTest(options);
    if (ecosystem) {
        try {
            const commandResult = await ecosystems_1.testEcosystem(ecosystem, paths, options);
            return commandResult;
        }
        catch (error) {
            if (error instanceof Error) {
                throw error;
            }
            else {
                throw new Error(error);
            }
        }
    }
    const resultOptions = [];
    const results = [];
    // Promise waterfall to test all other paths sequentially
    for (const path of paths) {
        // Create a copy of the options so a specific test can
        // modify them i.e. add `options.file` etc. We'll need
        // these options later.
        const testOpts = cloneDeep(options);
        testOpts.path = path;
        testOpts.projectName = testOpts['project-name'];
        let res;
        try {
            res = await snyk.test(path, testOpts);
        }
        catch (error) {
            // not throwing here but instead returning error response
            // for legacy flow reasons.
            res = format_test_error_1.formatTestError(error);
        }
        // Not all test results are arrays in order to be backwards compatible
        // with scripts that use a callback with test. Coerce results/errors to be arrays
        // and add the result options to each to be displayed
        const resArray = Array.isArray(res) ? res : [res];
        for (let i = 0; i < resArray.length; i++) {
            const pathWithOptionalProjectName = utils.getPathWithOptionalProjectName(path, resArray[i]);
            results.push(assign(resArray[i], { path: pathWithOptionalProjectName }));
            // currently testOpts are identical for each test result returned even if it's for multiple projects.
            // we want to return the project names, so will need to be crafty in a way that makes sense.
            if (!testOpts.projectNames) {
                resultOptions.push(testOpts);
            }
            else {
                resultOptions.push(assign(cloneDeep(testOpts), {
                    projectName: testOpts.projectNames[i],
                }));
            }
        }
    }
    const vulnerableResults = results.filter((res) => (res.vulnerabilities && res.vulnerabilities.length) ||
        (res.result &&
            res.result.cloudConfigResults &&
            res.result.cloudConfigResults.length));
    const errorResults = results.filter((res) => res instanceof Error);
    const notSuccess = errorResults.length > 0;
    const foundVulnerabilities = vulnerableResults.length > 0;
    // resultOptions is now an array of 1 or more options used for
    // the tests results is now an array of 1 or more test results
    // values depend on `options.json` value - string or object
    const mappedResults = format_test_results_1.createErrorMappedResultsForJsonOutput(results);
    const { stdout: dataToSend, stringifiedData, stringifiedJsonData, stringifiedSarifData, } = format_test_results_1.extractDataToSendFromResults(results, mappedResults, options);
    if (options.json || options.sarif) {
        // if all results are ok (.ok == true)
        if (mappedResults.every((res) => res.ok)) {
            return types_1.TestCommandResult.createJsonTestCommandResult(stringifiedData, stringifiedJsonData, stringifiedSarifData);
        }
        const err = new Error(stringifiedData);
        if (foundVulnerabilities) {
            if (options.failOn) {
                const fail = shouldFail(vulnerableResults, options.failOn);
                if (!fail) {
                    // return here to prevent failure
                    return types_1.TestCommandResult.createJsonTestCommandResult(stringifiedData, stringifiedJsonData, stringifiedSarifData);
                }
            }
            err.code = 'VULNS';
            const dataToSendNoVulns = dataToSend;
            delete dataToSendNoVulns.vulnerabilities;
            err.jsonNoVulns = dataToSendNoVulns;
        }
        if (notSuccess) {
            // Take the code of the first problem to go through error
            // translation.
            // Note: this is done based on the logic done below
            // for non-json/sarif outputs, where we take the code of
            // the first error.
            err.code = errorResults[0].code;
        }
        err.json = stringifiedData;
        err.jsonStringifiedResults = stringifiedJsonData;
        err.sarifStringifiedResults = stringifiedSarifData;
        throw err;
    }
    let response = results
        .map((result, i) => {
        return display_result_1.displayResult(results[i], resultOptions[i], result.foundProjectCount);
    })
        .join(`\n${SEPARATOR}`);
    if (notSuccess) {
        debug(`Failed to test ${errorResults.length} projects, errors:`);
        errorResults.forEach((err) => {
            const errString = err.stack ? err.stack.toString() : err.toString();
            debug('error: %s', errString);
        });
    }
    let summaryMessage = '';
    const errorResultsLength = errorResults.length;
    if (results.length > 1) {
        const projects = results.length === 1 ? 'project' : 'projects';
        summaryMessage =
            `\n\n\nTested ${results.length} ${projects}` +
                formatters_1.summariseVulnerableResults(vulnerableResults, options) +
                formatters_1.summariseErrorResults(errorResultsLength) +
                '\n';
    }
    if (notSuccess) {
        response += chalk_1.default.bold.red(summaryMessage);
        const error = new Error(response);
        // take the code of the first problem to go through error
        // translation
        // HACK as there can be different errors, and we pass only the
        // first one
        error.code = errorResults[0].code;
        error.userMessage = errorResults[0].userMessage;
        error.strCode = errorResults[0].strCode;
        throw error;
    }
    if (foundVulnerabilities) {
        if (options.failOn) {
            const fail = shouldFail(vulnerableResults, options.failOn);
            if (!fail) {
                // return here to prevent throwing failure
                response += chalk_1.default.bold.green(summaryMessage);
                response += os_1.EOL + os_1.EOL;
                response += protect_update_notification_1.getProtectUpgradeWarningForPaths(packageJsonPathsWithSnykDepForProtect);
                return types_1.TestCommandResult.createHumanReadableTestCommandResult(response, stringifiedJsonData, stringifiedSarifData);
            }
        }
        response += chalk_1.default.bold.red(summaryMessage);
        response += os_1.EOL + os_1.EOL;
        const foundSpotlightVulnIds = spotlight_vuln_notification_1.containsSpotlightVulnIds(results);
        const spotlightVulnsMsg = spotlight_vuln_notification_1.notificationForSpotlightVulns(foundSpotlightVulnIds);
        response += spotlightVulnsMsg;
        const error = new Error(response);
        // take the code of the first problem to go through error
        // translation
        // HACK as there can be different errors, and we pass only the
        // first one
        error.code = vulnerableResults[0].code || 'VULNS';
        error.userMessage = vulnerableResults[0].userMessage;
        error.jsonStringifiedResults = stringifiedJsonData;
        error.sarifStringifiedResults = stringifiedSarifData;
        throw error;
    }
    response += chalk_1.default.bold.green(summaryMessage);
    response += os_1.EOL + os_1.EOL;
    response += protect_update_notification_1.getProtectUpgradeWarningForPaths(packageJsonPathsWithSnykDepForProtect);
    return types_1.TestCommandResult.createHumanReadableTestCommandResult(response, stringifiedJsonData, stringifiedSarifData);
}
exports.default = test;
function shouldFail(vulnerableResults, failOn) {
    // find reasons not to fail
    if (failOn === 'all') {
        return vuln_helpers_1.hasFixes(vulnerableResults);
    }
    if (failOn === 'upgradable') {
        return vuln_helpers_1.hasUpgrades(vulnerableResults);
    }
    if (failOn === 'patchable') {
        return vuln_helpers_1.hasPatches(vulnerableResults);
    }
    // should fail by default when there are vulnerable results
    return vulnerableResults.length > 0;
}


/***/ }),

/***/ 79304:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPackageJsonPathsContainingSnykDependency = exports.checkPackageJsonForSnykDependency = exports.packageJsonFileExistsInDirectory = exports.getProtectUpgradeWarningForPaths = void 0;
const os_1 = __webpack_require__(12087);
const theme = __webpack_require__(86988);
const fs = __webpack_require__(35747);
const path = __webpack_require__(85622);
const createDebug = __webpack_require__(15158);
const debug = createDebug('snyk-protect-update-notification');
function getProtectUpgradeWarningForPaths(packageJsonPaths) {
    try {
        if ((packageJsonPaths === null || packageJsonPaths === void 0 ? void 0 : packageJsonPaths.length) > 0) {
            let message = theme.color.status.warn(`${theme.icon.WARNING} WARNING: It looks like you have the \`snyk\` dependency in the \`package.json\` file(s) at the following path(s):` +
                os_1.EOL);
            packageJsonPaths.forEach((p) => {
                message += theme.color.status.warn(`  - ${p}` + os_1.EOL);
            });
            const githubReadmeUrlShort = 'https://snyk.co/ud1cR'; // https://github.com/snyk/snyk/tree/master/packages/snyk-protect#migrating-from-snyk-protect-to-snykprotect
            message += theme.color.status.warn(`For more information and migration instructions, see ${githubReadmeUrlShort}` +
                os_1.EOL);
            return message;
        }
        else {
            return '';
        }
    }
    catch (e) {
        debug('Error in getProtectUpgradeWarningForPaths()', e);
        return '';
    }
}
exports.getProtectUpgradeWarningForPaths = getProtectUpgradeWarningForPaths;
function packageJsonFileExistsInDirectory(directoryPath) {
    try {
        const packageJsonPath = path.resolve(directoryPath, 'package.json');
        const fileExists = fs.existsSync(packageJsonPath);
        return fileExists;
    }
    catch (e) {
        debug('Error in packageJsonFileExistsInDirectory()', e);
        return false;
    }
}
exports.packageJsonFileExistsInDirectory = packageJsonFileExistsInDirectory;
function checkPackageJsonForSnykDependency(packageJsonPath) {
    try {
        const fileExists = fs.existsSync(packageJsonPath);
        if (fileExists) {
            const packageJson = fs.readFileSync(packageJsonPath, 'utf8');
            const packageJsonObject = JSON.parse(packageJson);
            const snykDependency = packageJsonObject.dependencies['snyk'];
            if (snykDependency) {
                return true;
            }
        }
    }
    catch (e) {
        debug('Error in checkPackageJsonForSnykDependency()', e);
    }
    return false;
}
exports.checkPackageJsonForSnykDependency = checkPackageJsonForSnykDependency;
function getPackageJsonPathsContainingSnykDependency(fileOption, paths) {
    const packageJsonPathsWithSnykDepForProtect = [];
    try {
        if (fileOption) {
            if (fileOption.endsWith('package.json') ||
                fileOption.endsWith('package-lock.json')) {
                const directoryWithPackageJson = path.dirname(fileOption);
                if (packageJsonFileExistsInDirectory(directoryWithPackageJson)) {
                    const packageJsonPath = path.resolve(directoryWithPackageJson, 'package.json');
                    const packageJsonContainsSnykDep = checkPackageJsonForSnykDependency(packageJsonPath);
                    if (packageJsonContainsSnykDep) {
                        packageJsonPathsWithSnykDepForProtect.push(packageJsonPath);
                    }
                }
            }
        }
        else {
            paths.forEach((testPath) => {
                if (packageJsonFileExistsInDirectory(testPath)) {
                    const packageJsonPath = path.resolve(testPath, 'package.json');
                    const packageJsonContainsSnykDep = checkPackageJsonForSnykDependency(packageJsonPath);
                    if (packageJsonContainsSnykDep) {
                        packageJsonPathsWithSnykDepForProtect.push(packageJsonPath);
                    }
                }
            });
        }
    }
    catch (e) {
        debug('Error in getPackageJsonPathsContainingSnykDependency()', e);
    }
    return packageJsonPathsWithSnykDepForProtect;
}
exports.getPackageJsonPathsContainingSnykDependency = getPackageJsonPathsContainingSnykDependency;


/***/ }),

/***/ 24083:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.notificationForSpotlightVulns = exports.containsSpotlightVulnIds = void 0;
const theme = __webpack_require__(86988);
const createDebug = __webpack_require__(15158);
const os_1 = __webpack_require__(12087);
const debug = createDebug('snyk-spotlight-vuln-notification');
const spotlightVulnIds = ['SNYK-JAVA-ORGAPACHELOGGINGLOG4J-2314720'];
function containsSpotlightVulnIds(results) {
    try {
        const spotlightVulnsFound = new Set();
        for (const r of results) {
            if (r.vulnerabilities) {
                for (const v of r.vulnerabilities) {
                    if (spotlightVulnIds.includes(v.id)) {
                        spotlightVulnsFound.add(v.id);
                    }
                }
            }
        }
        return [...spotlightVulnsFound];
    }
    catch (err) {
        debug('Error in containsSpotlightVulnIds()', err);
        return [];
    }
}
exports.containsSpotlightVulnIds = containsSpotlightVulnIds;
function notificationForSpotlightVulns(foundSpotlightVulnsIds) {
    try {
        if (foundSpotlightVulnsIds.length > 0) {
            let message = '';
            for (const vulnId of spotlightVulnIds) {
                if (vulnId === 'SNYK-JAVA-ORGAPACHELOGGINGLOG4J-2314720') {
                    message += theme.color.severity.critical(`${theme.icon.WARNING} WARNING: Critical severity vulnerabilities were found with Log4j!` +
                        os_1.EOL);
                    for (const vulnId of foundSpotlightVulnsIds) {
                        message += `  - ${vulnId} (See https://snyk.io/vuln/${vulnId})`;
                    }
                    message += os_1.EOL + os_1.EOL;
                    message +=
                        theme.color.severity.critical(`We highly recommend fixing this vulnerability. If it cannot be fixed by upgrading, see mitigation information here:`) +
                            os_1.EOL +
                            '  - https://security.snyk.io/vuln/SNYK-JAVA-ORGAPACHELOGGINGLOG4J-2314720' +
                            os_1.EOL +
                            '  - https://snyk.io/blog/log4shell-remediation-cheat-sheet/' +
                            os_1.EOL;
                }
            }
            return message;
        }
        return '';
    }
    catch (err) {
        debug('Error in notificationForSpotlightVulns()', err);
        return '';
    }
}
exports.notificationForSpotlightVulns = notificationForSpotlightVulns;


/***/ })

};
;
//# sourceMappingURL=917.index.js.map